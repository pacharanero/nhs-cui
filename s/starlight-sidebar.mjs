#!/usr/bin/env node
import fs from 'node:fs';
import path from 'node:path';

/**
 * Removes simple markdown formatting from inline title text.
 * @param {string} text Raw heading text.
 * @returns {string} Plain title text.
 */
function stripInlineMarkdown(text) {
  return text
    .replace(/`([^`]+)`/g, '$1')
    .replace(/\*\*([^*]+)\*\*/g, '$1')
    .replace(/_([^_]+)_/g, '$1')
    .replace(/\*([^*]+)\*/g, '$1')
    .trim();
}

/**
 * Normalizes text for rough comparison matching.
 * @param {string} value Input text.
 * @returns {string} Normalized alphanumeric text.
 */
function normalize(value) {
  return value.toLowerCase().replace(/[^a-z0-9]+/g, '');
}

/**
 * Cleans OCR-derived title text.
 * @param {string} value Raw candidate title.
 * @returns {string} Normalized title candidate.
 */
function cleanCandidateTitle(value) {
  return stripInlineMarkdown(value)
    .replace(/\s+\d+\.\d+\.\d+\.\d+$/g, '')
    .replace(/\s+/g, ' ')
    .trim();
}

/**
 * Returns whether a title candidate looks like a reference list item.
 * @param {string} value Candidate title.
 * @returns {boolean} True when the candidate should be ignored.
 */
function isLikelyReferenceNoise(value) {
  const lowered = value.toLowerCase();
  return (
    lowered.startsWith('design guide entry') ||
    lowered.startsWith('nhs cui programme') ||
    lowered.startsWith('recording ') ||
    lowered.includes('documents replaced by this document') ||
    lowered.includes('documents to be read in conjunction')
  );
}

/**
 * Loads optional PDF link-title manifest generated by s/download-cui.
 * @param {string} manifestPath Path to JSON manifest file.
 * @returns {Map<string, string>} Map of section/file path to title.
 */
function loadManifestTitles(manifestPath = 'pdfs/_link-manifest.json') {
  const mapping = new Map();
  if (!fs.existsSync(manifestPath)) {
    return mapping;
  }

  try {
    const raw = fs.readFileSync(manifestPath, 'utf-8');
    const entries = JSON.parse(raw);
    if (!Array.isArray(entries)) {
      return mapping;
    }

    for (const entry of entries) {
      if (!entry || typeof entry !== 'object') {
        continue;
      }
      const relativePath = typeof entry.relative_path === 'string' ? entry.relative_path : '';
      const title = typeof entry.title === 'string' ? stripInlineMarkdown(entry.title) : '';
      if (!relativePath || !title) {
        continue;
      }
      const cleaned = title.replace(/\s*\(PDF,\s*[^)]+\)\s*$/i, '').trim();
      mapping.set(relativePath.toLowerCase(), cleaned || title.trim());
    }
  } catch {
    return mapping;
  }

  return mapping;
}

/**
 * Converts slug-like path segments into readable labels.
 * @param {string} value Path segment.
 * @returns {string} Human-readable label.
 */
function humanize(value) {
  return value
    .replace(/[-_]+/g, ' ')
    .replace(/\b\w/g, (character) => character.toUpperCase());
}

/**
 * Recursively collects markdown files from a root directory.
 * @param {string} rootDirectory Root directory containing markdown files.
 * @returns {string[]} Relative markdown paths.
 */
function collectMarkdownFiles(rootDirectory) {
  const discoveredFiles = [];

  /**
   * Walks one directory level recursively.
   * @param {string} currentDirectory Current absolute directory path.
   */
  function walk(currentDirectory) {
    const entries = fs.readdirSync(currentDirectory, { withFileTypes: true });
    for (const entry of entries) {
      const absolutePath = path.join(currentDirectory, entry.name);
      if (entry.isDirectory()) {
        walk(absolutePath);
        continue;
      }
      if (entry.isFile() && entry.name.endsWith('.md')) {
        discoveredFiles.push(path.relative(rootDirectory, absolutePath).replace(/\\/g, '/'));
      }
    }
  }

  walk(rootDirectory);
  return discoveredFiles.sort((left, right) => left.localeCompare(right));
}

/**
 * Extracts a page title from the first markdown heading.
 * @param {string} absoluteFilePath Absolute markdown file path.
 * @param {string} fallbackPath Relative markdown path fallback.
 * @returns {string} Page title.
 */
function extractTitle(absoluteFilePath, fallbackPath, manifestTitles = new Map()) {
  const markdownText = fs.readFileSync(absoluteFilePath, 'utf-8');
  const stem = path.basename(fallbackPath, '.md');
  const normalizedStem = normalize(stem);
  const manifestKey = `${path.posix.dirname(fallbackPath)}/${path.posix.basename(fallbackPath, '.md')}.pdf`
    .replace(/^\.\//, '')
    .toLowerCase();

  const manifestTitle = manifestTitles.get(manifestKey);
  if (manifestTitle) {
    return manifestTitle;
  }

  const firstHeadingMatch = markdownText.match(/^#\s+(.+)$/m);
  if (firstHeadingMatch) {
    return stripInlineMarkdown(firstHeadingMatch[1]);
  }

  const titleCandidates = [];

  for (const match of markdownText.matchAll(/Document Title\s+(.+?)\s+User Interface Design Guidance/gi)) {
    titleCandidates.push(cleanCandidateTitle(match[1]));
  }

  for (const line of markdownText.split(/\r?\n/)) {
    const guidanceLineMatch = line.match(/(.+?)\s+[â€“-]\s+User Interface Design Guidance(?:\s+\d+\.\d+\.\d+\.\d+)?$/i);
    if (guidanceLineMatch) {
      titleCandidates.push(cleanCandidateTitle(guidanceLineMatch[1]));
    }
  }

  const filteredCandidates = titleCandidates.filter((value) => value.length > 2 && !isLikelyReferenceNoise(value));

  const stemAligned = filteredCandidates.find((candidate) => normalize(candidate).includes(normalizedStem));
  if (stemAligned) {
    return stemAligned;
  }

  if (filteredCandidates.length > 0) {
    return filteredCandidates[0];
  }

  const frontmatterTitleMatch = markdownText.match(/^---\s*[\s\S]*?^\s*title:\s*["']?(.+?)["']?\s*$[\s\S]*?^---\s*$/m);
  if (frontmatterTitleMatch) {
    return stripInlineMarkdown(frontmatterTitleMatch[1]);
  }
  return humanize(path.basename(fallbackPath, '.md'));
}

/**
 * Builds a Starlight sidebar configuration from the markdown directory.
 * @param {string} markdownRoot Root directory containing the markdown corpus.
 * @returns {Array<object>} Sidebar section configuration.
 */
export function buildSidebar(markdownRoot = 'markdown') {
  const relativeFiles = collectMarkdownFiles(markdownRoot).filter((filePath) => filePath !== 'index.md');
  const groupedEntries = new Map();
  const manifestTitles = loadManifestTitles();

  for (const relativeFilePath of relativeFiles) {
    const sectionKey = path.posix.dirname(relativeFilePath);
    const absoluteFilePath = path.join(markdownRoot, relativeFilePath);
    const title = extractTitle(absoluteFilePath, relativeFilePath, manifestTitles);
    const link = `/${relativeFilePath.replace(/\.md$/, '')}/`;

    if (!groupedEntries.has(sectionKey)) {
      groupedEntries.set(sectionKey, []);
    }

    groupedEntries.get(sectionKey).push({
      label: title,
      link
    });
  }

  const sidebarSections = [];
  for (const [sectionKey, items] of [...groupedEntries.entries()].sort((a, b) => a[0].localeCompare(b[0]))) {
    sidebarSections.push({
      label: sectionKey === '.' ? 'Documents' : humanize(sectionKey),
      items: items.sort((left, right) => left.label.localeCompare(right.label))
    });
  }

  return sidebarSections;
}
